{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Elements = require('./Elements');\n\nvar _Provider = require('./Provider');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // react-redux does a bunch of stuff with pure components / checking if it needs to re-render.\n// not sure if we need to do the same.\n\n\nvar inject = function inject(WrappedComponent) {\n  var _class, _temp;\n\n  var componentOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _componentOptions$wit = componentOptions.withRef,\n      withRef = _componentOptions$wit === undefined ? false : _componentOptions$wit;\n  return _temp = _class = function (_React$Component) {\n    _inherits(_class, _React$Component);\n\n    function _class(props, context) {\n      _classCallCheck(this, _class);\n\n      if (!context || !context.getRegisteredElements) {\n        throw new Error('It looks like you are trying to inject Stripe context outside of an Elements context.\\nPlease be sure the component that calls createSource or createToken is within an <Elements> component.');\n      }\n\n      var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n      _this.parseElementOrData = function (elementOrOptions) {\n        return elementOrOptions && (typeof elementOrOptions === 'undefined' ? 'undefined' : _typeof(elementOrOptions)) === 'object' && elementOrOptions._frame && _typeof(elementOrOptions._frame) === 'object' && elementOrOptions._frame.id && typeof elementOrOptions._frame.id === 'string' && typeof elementOrOptions._componentName === 'string' ? {\n          type: 'element',\n          element: elementOrOptions\n        } : {\n          type: 'data',\n          data: elementOrOptions\n        };\n      };\n\n      _this.findElement = function (filterBy, specifiedType) {\n        var allElements = _this.context.getRegisteredElements();\n\n        var filteredElements = allElements.filter(function (e) {\n          return e[filterBy];\n        });\n        var matchingElements = specifiedType === 'auto' ? filteredElements : filteredElements.filter(function (e) {\n          return e[filterBy] === specifiedType;\n        });\n\n        if (matchingElements.length === 1) {\n          return matchingElements[0].element;\n        } else if (matchingElements.length > 1) {\n          throw new Error('You did not specify the type of Source, Token, or PaymentMethod to create.\\n        We could not infer which Element you want to use for this operation.');\n        } else {\n          return null;\n        }\n      };\n\n      _this.requireElement = function (filterBy, specifiedType) {\n        var element = _this.findElement(filterBy, specifiedType);\n\n        if (element) {\n          return element;\n        } else {\n          throw new Error('You did not specify the type of Source, Token, or PaymentMethod to create.\\n        We could not infer which Element you want to use for this operation.');\n        }\n      };\n\n      _this.wrappedCreateToken = function (stripe) {\n        return function () {\n          var tokenTypeOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          if (tokenTypeOrOptions && (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) === 'object') {\n            // First argument is options; infer the Element and tokenize\n            var opts = tokenTypeOrOptions;\n\n            var tokenType = opts.type,\n                rest = _objectWithoutProperties(opts, ['type']);\n\n            var specifiedType = typeof tokenType === 'string' ? tokenType : 'auto'; // Since only options were passed in, a corresponding Element must exist\n            // for the tokenization to succeed -- thus we call requireElement.\n\n            var element = _this.requireElement('impliedTokenType', specifiedType);\n\n            return stripe.createToken(element, rest);\n          } else if (typeof tokenTypeOrOptions === 'string') {\n            // First argument is token type; tokenize with token type and options\n            var _tokenType = tokenTypeOrOptions;\n            return stripe.createToken(_tokenType, options);\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createToken. Expected an object, got ' + (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedCreateSource = function (stripe) {\n        return function () {\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            if (typeof options.type !== 'string') {\n              throw new Error('Invalid Source type passed to createSource. Expected string, got ' + _typeof(options.type) + '.');\n            }\n\n            var element = _this.findElement('impliedSourceType', options.type);\n\n            if (element) {\n              // If an Element exists for the source type, use that to create the\n              // corresponding source.\n              //\n              // NOTE: this prevents users from independently creating sources of\n              // type `foo` if an Element that can create `foo` sources exists in\n              // the current <Elements /> context.\n              return stripe.createSource(element, options);\n            } else {\n              // If no Element exists for the source type, directly create a source.\n              return stripe.createSource(options);\n            }\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createSource. Expected an object, got ' + (typeof options === 'undefined' ? 'undefined' : _typeof(options)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedCreatePaymentMethod = function (stripe) {\n        return function (paymentMethodType, elementOrData, maybeData) {\n          if (paymentMethodType && (typeof paymentMethodType === 'undefined' ? 'undefined' : _typeof(paymentMethodType)) === 'object') {\n            return stripe.createPaymentMethod(paymentMethodType);\n          }\n\n          if (!paymentMethodType || typeof paymentMethodType !== 'string') {\n            throw new Error('Invalid PaymentMethod type passed to createPaymentMethod. Expected a string, got ' + (typeof paymentMethodType === 'undefined' ? 'undefined' : _typeof(paymentMethodType)) + '.');\n          }\n\n          var elementOrDataResult = _this.parseElementOrData(elementOrData); // Second argument is Element; use passed in Element\n\n\n          if (elementOrDataResult.type === 'element') {\n            var _element = elementOrDataResult.element;\n\n            if (maybeData) {\n              return stripe.createPaymentMethod(paymentMethodType, _element, maybeData);\n            } else {\n              return stripe.createPaymentMethod(paymentMethodType, _element);\n            }\n          } // Second argument is data or undefined; infer the Element\n\n\n          var data = elementOrDataResult.data;\n\n          var element = _this.findElement('impliedPaymentMethodType', paymentMethodType);\n\n          if (element) {\n            return data ? stripe.createPaymentMethod(paymentMethodType, element, data) : stripe.createPaymentMethod(paymentMethodType, element);\n          }\n\n          if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {\n            return stripe.createPaymentMethod(paymentMethodType, data);\n          } else if (!data) {\n            throw new Error('Could not find an Element that can be used to create a PaymentMethod of type: ' + paymentMethodType + '.');\n          } else {\n            // If a bad value was passed in for data, throw an error.\n            throw new Error('Invalid data passed to createPaymentMethod. Expected an object, got ' + (typeof data === 'undefined' ? 'undefined' : _typeof(data)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedHandleCardX = function (stripe, method) {\n        return function (clientSecret, elementOrData, maybeData) {\n          if (!clientSecret || typeof clientSecret !== 'string') {\n            // If a bad value was passed in for clientSecret, throw an error.\n            throw new Error('Invalid PaymentIntent client secret passed to handleCardPayment. Expected string, got ' + (typeof clientSecret === 'undefined' ? 'undefined' : _typeof(clientSecret)) + '.');\n          }\n\n          var elementOrDataResult = _this.parseElementOrData(elementOrData); // Second argument is Element; handle with element\n\n\n          if (elementOrDataResult.type === 'element') {\n            var _element2 = elementOrDataResult.element;\n\n            if (maybeData) {\n              return stripe[method](clientSecret, _element2, maybeData);\n            } else {\n              return stripe[method](clientSecret, _element2);\n            }\n          } // Second argument is data or undefined; see if we can find a mounted Element\n          // that can create card PaymentMethods\n\n\n          var data = elementOrDataResult.data;\n\n          var element = _this.findElement('impliedPaymentMethodType', 'card');\n\n          if (element) {\n            // If an Element exists that can create card PaymentMethods use it. Otherwise\n            // assume that we must be calling with data only.\n            //\n            // NOTE: this prevents users from using handleCard* with an existing\n            // Source or PaymentMethod if an Element that can create card PaymentMethods\n            // exists in the current <Elements /> context.\n            if (data) {\n              return stripe[method](clientSecret, element, data);\n            } else {\n              return stripe[method](clientSecret, element);\n            }\n          } else if (data) {\n            // if no element exists call handleCard* directly (with data)\n            return stripe[method](clientSecret, data);\n          } else {\n            // if no element exists call handleCard* directly (with only the clientSecret)\n            return stripe[method](clientSecret);\n          }\n        };\n      };\n\n      if (_this.context.tag === 'sync') {\n        _this.state = {\n          stripe: _this.stripeProps(_this.context.stripe)\n        };\n      } else {\n        _this.state = {\n          stripe: null\n        };\n      }\n\n      return _this;\n    }\n\n    _class.prototype.componentDidMount = function componentDidMount() {\n      var _this2 = this;\n\n      if (this.context.tag === 'async') {\n        this.context.addStripeLoadListener(function (stripe) {\n          _this2.setState({\n            stripe: _this2.stripeProps(stripe)\n          });\n        });\n      } else {// when 'sync', it's already set in the constructor.\n      }\n    };\n\n    _class.prototype.getWrappedInstance = function getWrappedInstance() {\n      if (!withRef) {\n        throw new Error('To access the wrapped instance, the `{withRef: true}` option must be set when calling `injectStripe()`');\n      }\n\n      return this.wrappedInstance;\n    };\n\n    _class.prototype.stripeProps = function stripeProps(stripe) {\n      return _extends({}, stripe, {\n        // These are the only functions that take elements.\n        createToken: this.wrappedCreateToken(stripe),\n        createSource: this.wrappedCreateSource(stripe),\n        createPaymentMethod: this.wrappedCreatePaymentMethod(stripe),\n        handleCardPayment: this.wrappedHandleCardX(stripe, 'handleCardPayment'),\n        handleCardSetup: this.wrappedHandleCardX(stripe, 'handleCardSetup')\n      });\n    }; // Finds an Element by the specified type, if one exists.\n    // Throws if multiple Elements match.\n    // Require that exactly one Element is found for the specified type.\n    // Throws if no Element is found.\n    // Wraps createToken in order to infer the Element that is being tokenized.\n    // Wraps createSource in order to infer the Element that is being used for\n    // source creation.\n    // Wraps createPaymentMethod in order to infer the Element that is being\n    // used for PaymentMethod creation.\n\n\n    _class.prototype.render = function render() {\n      var _this3 = this;\n\n      return _react2.default.createElement(WrappedComponent, _extends({}, this.props, {\n        stripe: this.state.stripe,\n        elements: this.context.elements,\n        ref: withRef ? function (c) {\n          _this3.wrappedInstance = c;\n        } : null\n      }));\n    };\n\n    return _class;\n  }(_react2.default.Component), _class.contextTypes = _extends({}, _Provider.providerContextTypes, _Elements.injectContextTypes), _class.displayName = 'InjectStripe(' + (WrappedComponent.displayName || WrappedComponent.name || 'Component') + ')', _temp;\n};\n\nexports.default = inject;","map":{"version":3,"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_typeof","Symbol","iterator","obj","constructor","_react","require","_react2","_interopRequireDefault","_Elements","_Provider","__esModule","default","_objectWithoutProperties","keys","indexOf","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","enumerable","writable","configurable","setPrototypeOf","__proto__","inject","WrappedComponent","_class","_temp","componentOptions","undefined","_componentOptions$wit","withRef","_React$Component","props","context","getRegisteredElements","Error","_this","parseElementOrData","elementOrOptions","_frame","id","_componentName","type","element","data","findElement","filterBy","specifiedType","allElements","filteredElements","filter","e","matchingElements","requireElement","wrappedCreateToken","stripe","tokenTypeOrOptions","options","opts","tokenType","rest","createToken","_tokenType","wrappedCreateSource","createSource","wrappedCreatePaymentMethod","paymentMethodType","elementOrData","maybeData","createPaymentMethod","elementOrDataResult","_element","wrappedHandleCardX","method","clientSecret","_element2","tag","state","stripeProps","componentDidMount","_this2","addStripeLoadListener","setState","getWrappedInstance","wrappedInstance","handleCardPayment","handleCardSetup","render","_this3","createElement","elements","ref","c","Component","contextTypes","providerContextTypes","injectContextTypes","displayName","name"],"sources":["/home/asus/dapify/node_modules/react-stripe-elements/es/components/inject.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Elements = require('./Elements');\n\nvar _Provider = require('./Provider');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// react-redux does a bunch of stuff with pure components / checking if it needs to re-render.\n// not sure if we need to do the same.\nvar inject = function inject(WrappedComponent) {\n  var _class, _temp;\n\n  var componentOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _componentOptions$wit = componentOptions.withRef,\n      withRef = _componentOptions$wit === undefined ? false : _componentOptions$wit;\n\n\n  return _temp = _class = function (_React$Component) {\n    _inherits(_class, _React$Component);\n\n    function _class(props, context) {\n      _classCallCheck(this, _class);\n\n      if (!context || !context.getRegisteredElements) {\n        throw new Error('It looks like you are trying to inject Stripe context outside of an Elements context.\\nPlease be sure the component that calls createSource or createToken is within an <Elements> component.');\n      }\n\n      var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n      _this.parseElementOrData = function (elementOrOptions) {\n        return elementOrOptions && (typeof elementOrOptions === 'undefined' ? 'undefined' : _typeof(elementOrOptions)) === 'object' && elementOrOptions._frame && _typeof(elementOrOptions._frame) === 'object' && elementOrOptions._frame.id && typeof elementOrOptions._frame.id === 'string' && typeof elementOrOptions._componentName === 'string' ? { type: 'element', element: elementOrOptions } : { type: 'data', data: elementOrOptions };\n      };\n\n      _this.findElement = function (filterBy, specifiedType) {\n        var allElements = _this.context.getRegisteredElements();\n        var filteredElements = allElements.filter(function (e) {\n          return e[filterBy];\n        });\n        var matchingElements = specifiedType === 'auto' ? filteredElements : filteredElements.filter(function (e) {\n          return e[filterBy] === specifiedType;\n        });\n\n        if (matchingElements.length === 1) {\n          return matchingElements[0].element;\n        } else if (matchingElements.length > 1) {\n          throw new Error('You did not specify the type of Source, Token, or PaymentMethod to create.\\n        We could not infer which Element you want to use for this operation.');\n        } else {\n          return null;\n        }\n      };\n\n      _this.requireElement = function (filterBy, specifiedType) {\n        var element = _this.findElement(filterBy, specifiedType);\n        if (element) {\n          return element;\n        } else {\n          throw new Error('You did not specify the type of Source, Token, or PaymentMethod to create.\\n        We could not infer which Element you want to use for this operation.');\n        }\n      };\n\n      _this.wrappedCreateToken = function (stripe) {\n        return function () {\n          var tokenTypeOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          if (tokenTypeOrOptions && (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) === 'object') {\n            // First argument is options; infer the Element and tokenize\n            var opts = tokenTypeOrOptions;\n\n            var tokenType = opts.type,\n                rest = _objectWithoutProperties(opts, ['type']);\n\n            var specifiedType = typeof tokenType === 'string' ? tokenType : 'auto';\n            // Since only options were passed in, a corresponding Element must exist\n            // for the tokenization to succeed -- thus we call requireElement.\n            var element = _this.requireElement('impliedTokenType', specifiedType);\n            return stripe.createToken(element, rest);\n          } else if (typeof tokenTypeOrOptions === 'string') {\n            // First argument is token type; tokenize with token type and options\n            var _tokenType = tokenTypeOrOptions;\n            return stripe.createToken(_tokenType, options);\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createToken. Expected an object, got ' + (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedCreateSource = function (stripe) {\n        return function () {\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            if (typeof options.type !== 'string') {\n              throw new Error('Invalid Source type passed to createSource. Expected string, got ' + _typeof(options.type) + '.');\n            }\n\n            var element = _this.findElement('impliedSourceType', options.type);\n            if (element) {\n              // If an Element exists for the source type, use that to create the\n              // corresponding source.\n              //\n              // NOTE: this prevents users from independently creating sources of\n              // type `foo` if an Element that can create `foo` sources exists in\n              // the current <Elements /> context.\n              return stripe.createSource(element, options);\n            } else {\n              // If no Element exists for the source type, directly create a source.\n              return stripe.createSource(options);\n            }\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createSource. Expected an object, got ' + (typeof options === 'undefined' ? 'undefined' : _typeof(options)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedCreatePaymentMethod = function (stripe) {\n        return function (paymentMethodType, elementOrData, maybeData) {\n          if (paymentMethodType && (typeof paymentMethodType === 'undefined' ? 'undefined' : _typeof(paymentMethodType)) === 'object') {\n            return stripe.createPaymentMethod(paymentMethodType);\n          }\n\n          if (!paymentMethodType || typeof paymentMethodType !== 'string') {\n            throw new Error('Invalid PaymentMethod type passed to createPaymentMethod. Expected a string, got ' + (typeof paymentMethodType === 'undefined' ? 'undefined' : _typeof(paymentMethodType)) + '.');\n          }\n\n          var elementOrDataResult = _this.parseElementOrData(elementOrData);\n\n          // Second argument is Element; use passed in Element\n          if (elementOrDataResult.type === 'element') {\n            var _element = elementOrDataResult.element;\n\n            if (maybeData) {\n              return stripe.createPaymentMethod(paymentMethodType, _element, maybeData);\n            } else {\n              return stripe.createPaymentMethod(paymentMethodType, _element);\n            }\n          }\n\n          // Second argument is data or undefined; infer the Element\n          var data = elementOrDataResult.data;\n\n          var element = _this.findElement('impliedPaymentMethodType', paymentMethodType);\n\n          if (element) {\n            return data ? stripe.createPaymentMethod(paymentMethodType, element, data) : stripe.createPaymentMethod(paymentMethodType, element);\n          }\n\n          if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {\n            return stripe.createPaymentMethod(paymentMethodType, data);\n          } else if (!data) {\n            throw new Error('Could not find an Element that can be used to create a PaymentMethod of type: ' + paymentMethodType + '.');\n          } else {\n            // If a bad value was passed in for data, throw an error.\n            throw new Error('Invalid data passed to createPaymentMethod. Expected an object, got ' + (typeof data === 'undefined' ? 'undefined' : _typeof(data)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedHandleCardX = function (stripe, method) {\n        return function (clientSecret, elementOrData, maybeData) {\n          if (!clientSecret || typeof clientSecret !== 'string') {\n            // If a bad value was passed in for clientSecret, throw an error.\n            throw new Error('Invalid PaymentIntent client secret passed to handleCardPayment. Expected string, got ' + (typeof clientSecret === 'undefined' ? 'undefined' : _typeof(clientSecret)) + '.');\n          }\n\n          var elementOrDataResult = _this.parseElementOrData(elementOrData);\n\n          // Second argument is Element; handle with element\n          if (elementOrDataResult.type === 'element') {\n            var _element2 = elementOrDataResult.element;\n\n            if (maybeData) {\n              return stripe[method](clientSecret, _element2, maybeData);\n            } else {\n              return stripe[method](clientSecret, _element2);\n            }\n          }\n\n          // Second argument is data or undefined; see if we can find a mounted Element\n          // that can create card PaymentMethods\n          var data = elementOrDataResult.data;\n\n          var element = _this.findElement('impliedPaymentMethodType', 'card');\n\n          if (element) {\n            // If an Element exists that can create card PaymentMethods use it. Otherwise\n            // assume that we must be calling with data only.\n            //\n            // NOTE: this prevents users from using handleCard* with an existing\n            // Source or PaymentMethod if an Element that can create card PaymentMethods\n            // exists in the current <Elements /> context.\n            if (data) {\n              return stripe[method](clientSecret, element, data);\n            } else {\n              return stripe[method](clientSecret, element);\n            }\n          } else if (data) {\n            // if no element exists call handleCard* directly (with data)\n            return stripe[method](clientSecret, data);\n          } else {\n            // if no element exists call handleCard* directly (with only the clientSecret)\n            return stripe[method](clientSecret);\n          }\n        };\n      };\n\n      if (_this.context.tag === 'sync') {\n        _this.state = {\n          stripe: _this.stripeProps(_this.context.stripe)\n        };\n      } else {\n        _this.state = {\n          stripe: null\n        };\n      }\n      return _this;\n    }\n\n    _class.prototype.componentDidMount = function componentDidMount() {\n      var _this2 = this;\n\n      if (this.context.tag === 'async') {\n        this.context.addStripeLoadListener(function (stripe) {\n          _this2.setState({\n            stripe: _this2.stripeProps(stripe)\n          });\n        });\n      } else {\n        // when 'sync', it's already set in the constructor.\n      }\n    };\n\n    _class.prototype.getWrappedInstance = function getWrappedInstance() {\n      if (!withRef) {\n        throw new Error('To access the wrapped instance, the `{withRef: true}` option must be set when calling `injectStripe()`');\n      }\n      return this.wrappedInstance;\n    };\n\n    _class.prototype.stripeProps = function stripeProps(stripe) {\n      return _extends({}, stripe, {\n        // These are the only functions that take elements.\n        createToken: this.wrappedCreateToken(stripe),\n        createSource: this.wrappedCreateSource(stripe),\n        createPaymentMethod: this.wrappedCreatePaymentMethod(stripe),\n        handleCardPayment: this.wrappedHandleCardX(stripe, 'handleCardPayment'),\n        handleCardSetup: this.wrappedHandleCardX(stripe, 'handleCardSetup')\n      });\n    };\n\n    // Finds an Element by the specified type, if one exists.\n    // Throws if multiple Elements match.\n\n\n    // Require that exactly one Element is found for the specified type.\n    // Throws if no Element is found.\n\n\n    // Wraps createToken in order to infer the Element that is being tokenized.\n\n\n    // Wraps createSource in order to infer the Element that is being used for\n    // source creation.\n\n\n    // Wraps createPaymentMethod in order to infer the Element that is being\n    // used for PaymentMethod creation.\n\n\n    _class.prototype.render = function render() {\n      var _this3 = this;\n\n      return _react2.default.createElement(WrappedComponent, _extends({}, this.props, {\n        stripe: this.state.stripe,\n        elements: this.context.elements,\n        ref: withRef ? function (c) {\n          _this3.wrappedInstance = c;\n        } : null\n      }));\n    };\n\n    return _class;\n  }(_react2.default.Component), _class.contextTypes = _extends({}, _Provider.providerContextTypes, _Elements.injectContextTypes), _class.displayName = 'InjectStripe(' + (WrappedComponent.displayName || WrappedComponent.name || 'Component') + ')', _temp;\n};\n\nexports.default = inject;"],"mappings":"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"},"metadata":{},"sourceType":"script"}